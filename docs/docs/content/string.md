## Content Family: String 

#### Content: String::Pattern

String values generated by a regular expression in the `pattern` parameter. The below will generated Strings like `bla` or `blabla` or `blablabla` and so on.

###### Example

```json
"bla_bla_bla" : {    
    "pattern": "(bla)+",
    "type": "string"
}
```

###### Example Output
```json
[
    {
      "bla_bla_bla": "blablablablablablablablablablablablablablablablablablablablabla"
    },
    {
      "bla_bla_bla": "blablablablablablablablablablablablablablablablablablablablablablablablabla"
    },
    {
      "bla_bla_bla": "blablablablablablablablablablablablabla"
    },
    {
      "bla_bla_bla": "blablablablablablablablablablablablablabla"
    },
    {
      "bla_bla_bla": "blablablablablablablablablablablablablablablablablablablablablablabla"
    }
  ]

```

#### Content: String::Faker

This offers integration with the python Faker library. Faker offers a variety of different fake data, in different locals and can be accessed easily from Synth.

For more information on the different types of faker generators see Faker's [documentation](https://faker.readthedocs.io/en/master/).

The below example generates fake credit card numbers. 

Since Faker generators can take arbitrary parameters, the `String::Faker` content type can accept arbitrary key/value pairs. In the below example this is `"card_type" : "amex"`

`String::Faker` also supports locales, which can be specified using the *optional* `locales` property.

###### Example

```json
"credit_card": {
  "type": "string",
  "faker": {
    "generator": "credit_card_number",
    "card_type": "amex",
    "locales" : ["en_GB"]
  }
},
```

###### Example Output

```json
[
    {
      "credit_card": "341906447099439"
    },
    {
      "credit_card": "345700140739631"
    },
    {
      "credit_card": "378500663476771"
    },
    {
      "credit_card": "347802667649678"
    },
    {
      "credit_card": "375235715161245"
    }
  ]

```

#### Content: String::DateTime

`String::DateTime` is a content type representing ISO 8601 dates and times.

The DateTime appearance can be set via the `format` property - as well as specifying the possible datetime intervals using the `begin` and `end` properties.


###### Example

```json
"last_login_at" : {
    "type": "string",
    "date_time": {
        "format": "%Y-%m-%dT%H:%M:%S%z",
        "begin": "2015-01-01T00:00:00+0000",
        "end": "2020-01-01T00:00:00+0000"
    }
},
```

###### Example Output

```json
[
    {
      "last_login_at": "2016-07-28T15:00:48+0000"
    },
    {
      "last_login_at": "2016-01-05T16:25:56+0000"
    },
    {
      "last_login_at": "2015-03-26T16:01:41+0000"
    },
    {
      "last_login_at": "2016-04-05T21:49:33+0000"
    },
    {
      "last_login_at": "2015-01-03T03:10:53+0000"
    }
  ]

```

#### Content: Categorical::String
The `String::Categorical` is a content type which can take one out of a finite set of user-defined values.

Categoricals also maintain a probability distribution under the hood which represents how many times a certain element has been seen by Synth. The distribution is derived from the number of occurences of each variant of the categorical.

###### Example
```json
"chess_piece" : {
     "type": "string",
     "categorical": {
         "pawn": 8,
         "rook": 2,
         "knight": 2,
         "bishop": 2,
         "queen": 1,
         "king": 1
     }
 }
```

###### Example Output

```json
[
    {
      "chess_piece": "knight"
    },
    {
      "chess_piece": "pawn"
    },
    {
      "chess_piece": "pawn"
    },
    {
      "chess_piece": "rook"
    },
    {
      "chess_piece": "pawn"
    }
  ]
```